<html>
<head style="background-color:#0b1220">
  <meta charset="UTF-8">
  <title>Main</title>
  <script src="./main.js"></script>
</head>

<body style="background-color:#0b1220">
<script>
document.getElementById('unlockAudio').addEventListener('click', async () => {
    // create audioCtx if it doesn't exist yet
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }

    // resume if suspended (required for autoplay policy)
    if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
    }
});
</script>

  <div id="myapp"></div>
    <script>
    var app = Elm.Main.init({ node: document.getElementById('myapp') });

    // Lazy audio context (created on first user gesture/play)
    let audioCtx = null;
    let soundsLoaded = false;
    const soundLibrary = { click: null, store: null, achievement: null };
    let blockUntil = 0;

    async function ensureAudioReady() {
        if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        // resume if suspended (must be from a user gesture in many browsers)
        if (audioCtx.state === 'suspended') {
        try { await audioCtx.resume(); } catch (e) { console.warn('resume failed', e); }
        }
        if (!soundsLoaded) {
        // load and decode all sounds in parallel
        await Promise.all([
            loadSound('click', 'audio/click1.wav'),
            loadSound('store', 'audio/store.wav'),
            loadSound('achievement', 'audio/achievement.wav'),
        ]);
        soundsLoaded = true;
        }
    }

    async function loadSound(name, url) {
        try {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        // decodeAudioData returns a Promise in modern browsers
        soundLibrary[name] = await audioCtx.decodeAudioData(arrayBuffer);
        console.log(`Loaded: ${name}`);
        } catch (e) {
        console.error(`Failed to load sound "${name}" from ${url}:`, e);
        soundLibrary[name] = null;
        }
    }

    function playBuffer(buffer, time, volume = 1.0) {
        if (!buffer) return 0;
        const source = audioCtx.createBufferSource();
        const gainNode = audioCtx.createGain();

        source.buffer = buffer;
        gainNode.gain.value = volume;

        source.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        // schedule start; provide a fallback to currentTime
        const startAt = (typeof time === 'number' && !isNaN(time)) ? time : audioCtx.currentTime;
        source.start(startAt);
        return buffer.duration || 0;
    }

    app.ports.playSound.subscribe(async function(type) {
        // Ensure audio context exists and sounds are decoded.
        // This will resume/create audio only when the user triggers a port call.
        try {
        await ensureAudioReady();
        } catch (e) {
        console.error('Audio init failed', e);
        return;
        }

        const now = audioCtx.currentTime;

        // ignore if a priority sequence is playing
        if (now < blockUntil) return;

        switch (type) {
        case 'click':
            playBuffer(soundLibrary.click, now, 0.3);
            break;

        case 'store':
            playBuffer(soundLibrary.store, now);
            break;

        case 'achievement': {
            const d = playBuffer(soundLibrary.achievement, now);
            // blockUntil = now + d;
            break;
        }

        case 'clickAch':
            if (soundLibrary.click && soundLibrary.achievement) {
            const d1 = playBuffer(soundLibrary.click, now, 0.3);;
            const d2 = playBuffer(soundLibrary.achievement, now + d1);
            blockUntil = now + d1 + d2;
            }
            break;

        case 'storeAch':
            if (soundLibrary.store && soundLibrary.achievement) {
            const d1 = playBuffer(soundLibrary.store, now);;
            const d2 = playBuffer(soundLibrary.achievement, now + d1);
            blockUntil = now + d1 + d2;
            }
            break;

        default:
            console.warn('Unknown sound type:', type);
        }
    });

    // Optional: if you want to proactively unlock audio on any user gesture (helpful for mobile)
    document.addEventListener('click', function unlockOnce() {
        if (!audioCtx) return; // will be created lazily anyway
        if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(e => console.warn('unlock resume failed', e));
        }
        document.removeEventListener('click', unlockOnce);
    });
    </script>

</body>
</html>